"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hdKeyFromSeed = hdKeyFromSeed;
var _util = require("@polkadot/util");
var _ed = require("../ed25519");
var _hmac = require("../hmac");
var _secp256k = require("../secp256k1");
// Copyright 2021-2023 zcloak authors & contributors
// SPDX-License-Identifier: Apache-2.0

// References:
// https://github.com/satoshilabs/slips/blob/master/slip-0010.md
// https://github.com/satoshilabs/slips/blob/master/slip-0032.md
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md

const MASTER_SECRET = {
  secp256k1: (0, _util.stringToU8a)('Bitcoin seed'),
  ed25519: (0, _util.stringToU8a)('ed25519 seed')
};
const PublicFromType = {
  secp256k1: seed => (0, _secp256k.secp256k1PairFromSeed)(seed).publicKey,
  ed25519: seed => (0, _ed.ed25519PairFromSeed)(seed).publicKey
};
const HARDENED = 0x80000000;
const BN_BE_32_OPTS = {
  bitLength: 32,
  isLe: false
};
function hdValidatePath(path) {
  if (!path.startsWith('m/')) {
    return false;
  }
  const parts = path.split('/').slice(1);
  for (const p of parts) {
    const n = /^\d+'?$/.test(p) ? parseInt(p.replace(/'$/, ''), 10) : Number.NaN;
    if (isNaN(n) || n >= HARDENED || n < 0) {
      return false;
    }
  }
  return true;
}
function createCoded(seed, chainCode, curve) {
  return {
    chainCode,
    seed,
    publicKey: PublicFromType[curve](seed)
  };
}
function deriveChild(hd, index, curve) {
  const indexBuffer = (0, _util.bnToU8a)(index, BN_BE_32_OPTS);
  const data = index >= HARDENED ? (0, _util.u8aConcat)(new Uint8Array(1), hd.seed, indexBuffer) : (0, _util.u8aConcat)(hd.publicKey, indexBuffer);
  try {
    const I = (0, _hmac.hmacShaAsU8a)(hd.chainCode, data, 512);
    return createCoded(curve === 'secp256k1' ? (0, _secp256k.secp256k1PrivateKeyTweakAdd)(hd.seed, I.slice(0, 32)) : I.slice(0, 32), I.slice(32), curve);
  } catch (err) {
    // In case parse256(IL) >= n or ki == 0, proceed with the next value for i
    return deriveChild(hd, index + 1, curve);
  }
}

/**
 * @name hdKeyFromSeed
 * @summary create hd key by seed and path
 * @description
 * create hd key by seed and path, support `curve` with 'secp256k1' and 'ed25519', Return `HdKey` Object.
 */
function hdKeyFromSeed(seed) {
  let curve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'secp256k1';
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  const I = (0, _hmac.hmacShaAsU8a)(MASTER_SECRET[curve], seed, 512);
  let hd = createCoded(I.slice(0, 32), I.slice(32), curve);
  if (!path || path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return hd;
  }
  if (!hdValidatePath(path)) {
    throw new Error('Invalid derivation path');
  }
  const parts = path.split('/').slice(1);
  for (const p of parts) {
    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith("'") ? HARDENED : 0), curve);
  }
  return hd;
}