// Copyright 2021-2023 zcloak authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable @typescript-eslint/no-non-null-assertion */

import { hexToU8a, stringToU8a, u8aToString } from '@polkadot/util';
export class WasmBridge {
  #cacheU8a = new Uint8Array();
  #cachedBigUint64 = new BigUint64Array();
  #cachedInt32 = new Int32Array();
  #heap = new Array(32).fill(undefined);
  #heapNext = this.#heap.length;
  getUint8() {
    if (this.#cacheU8a.byteLength === 0) {
      this.#cacheU8a = new Uint8Array(this.wasm.memory.buffer);
    }
    return this.#cacheU8a;
  }
  getUint64() {
    if (this.#cachedBigUint64.byteLength === 0) {
      this.#cachedBigUint64 = new BigUint64Array(this.wasm.memory.buffer);
    }
    return this.#cachedBigUint64;
  }
  getInt32() {
    if (this.#cachedInt32.byteLength === 0) {
      this.#cachedInt32 = new Int32Array(this.wasm.memory.buffer);
    }
    return this.#cachedInt32;
  }
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr, ptr + len);
  }
  getU64a(ptr, len) {
    return this.getUint64().subarray(ptr / 8, ptr / 8 + len);
  }
  allocU8a(value) {
    const ptr = this.wasm.__wbindgen_malloc(value.length);
    this.getUint8().set(value, ptr);
    return [ptr, value.length];
  }
  allocString(value) {
    return this.allocU8a(stringToU8a(value));
  }
  allocU64a(value) {
    const ptr = this.wasm.__wbindgen_malloc(value.length * 8);
    this.getUint64().set(value, ptr / 8);
    return [ptr, value.length];
  }
  resultU8a(retptr) {
    const r0 = this.getInt32()[retptr / 4 + 0];
    const r1 = this.getInt32()[retptr / 4 + 1];
    const v1 = this.getU8a(r0, r1).slice();
    this.wasm.__wbindgen_free(r0, r1);
    return v1;
  }
  resultString(retptr) {
    return u8aToString(this.resultU8a(retptr));
  }
  resultU64a(retptr) {
    const r0 = this.getInt32()[retptr / 4 + 0];
    const r1 = this.getInt32()[retptr / 4 + 1];
    const v1 = this.getU64a(r0, r1).slice();
    this.wasm.__wbindgen_free(r0, r1 * 8);
    return v1;
  }
  addHeapObject(obj) {
    if (this.#heapNext === this.#heap.length) this.#heap.push(this.#heap.length + 1);
    const idx = this.#heapNext;
    this.#heapNext = this.#heap[idx];
    this.#heap[idx] = obj;
    return idx;
  }
  getObject(idx) {
    return this.#heap[idx];
  }
  dropObject(idx) {
    if (idx < 36) return;
    this.#heap[idx] = this.#heapNext;
    this.#heapNext = idx;
  }
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }
  async initWasm(wasmBytes) {
    if (this.wasm) return;
    try {
      const source = await WebAssembly.instantiate(hexToU8a(wasmBytes));
      this.wasm = source.instance.exports;
    } catch (e) {
      console.error('Can not to init wasm, try to use asm');
    }
  }
  initAsm(asmBundle) {
    if (this.wasm) return;
    if (asmBundle) {
      this.wasm = asmBundle;
    }
  }
}